name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip quality gates)'
        required: false
        default: 'false'
        type: boolean

concurrency:
  group: staging-deployment
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  DEPLOYMENT_ENV: 'staging'
  NEXT_TELEMETRY_DISABLED: 1

jobs:
  # Pre-deployment Checks
  pre-deploy-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      deploy-ready: ${{ steps.checks.outputs.deploy-ready }}
      build-version: ${{ steps.version.outputs.build-version }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: |
          npm ci --prefer-offline --no-audit
          npm --workspace apps/web ci --prefer-offline --no-audit

      - name: Run Quality Checks
        if: github.event.inputs.force_deploy != 'true'
        run: |
          npm run typecheck
          npm run lint
          npm run test:ci

      - name: Generate Build Version
        id: version
        run: |
          BUILD_VERSION="staging-$(date +%Y%m%d)-${GITHUB_SHA:0:7}"
          echo "build-version=$BUILD_VERSION" >> $GITHUB_OUTPUT
          echo "BUILD_VERSION=$BUILD_VERSION" >> $GITHUB_ENV

      - name: Deployment Readiness Check
        id: checks
        run: |
          echo "deploy-ready=true" >> $GITHUB_OUTPUT

  # Build for Staging
  build-staging:
    name: Build for Staging
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks]
    if: needs.pre-deploy-checks.outputs.deploy-ready == 'true'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: |
          npm ci --prefer-offline --no-audit
          npm --workspace apps/web ci --prefer-offline --no-audit

      - name: Build Application
        run: npm run build:web
        env:
          NODE_ENV: production
          NEXT_TELEMETRY_DISABLED: 1
          # Staging environment variables
          NEXT_PUBLIC_APP_ENV: staging
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.STAGING_API_BASE_URL }}
          NEXT_PUBLIC_BLOCKCHAIN_NETWORK: ${{ secrets.STAGING_BLOCKCHAIN_NETWORK }}
          NEXT_PUBLIC_CONTRACT_ADDRESS: ${{ secrets.STAGING_CONTRACT_ADDRESS }}

      - name: Create Deployment Package
        run: |
          tar -czf staging-build-${{ needs.pre-deploy-checks.outputs.build-version }}.tar.gz \
            -C apps/web .next package.json next.config.mjs public/

      - name: Upload Staging Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-build-${{ needs.pre-deploy-checks.outputs.build-version }}
          path: staging-build-${{ needs.pre-deploy-checks.outputs.build-version }}.tar.gz
          retention-days: 30

  # Container Build and Push
  container-build:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, build-staging]
    outputs:
      image-tag: ${{ steps.image-info.outputs.image-tag }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY }}
          username: ${{ secrets.CONTAINER_REGISTRY_USERNAME }}
          password: ${{ secrets.CONTAINER_REGISTRY_PASSWORD }}

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: staging-build-${{ needs.pre-deploy-checks.outputs.build-version }}
          path: ./

      - name: Extract Build
        run: |
          mkdir -p apps/web
          tar -xzf staging-build-${{ needs.pre-deploy-checks.outputs.build-version }}.tar.gz -C apps/web/

      - name: Build and Push Container Image
        uses: docker/build-push-action@v5
        with:
          context: ./apps/web
          file: ./apps/web/Dockerfile.staging
          push: true
          tags: |
            ${{ secrets.CONTAINER_REGISTRY }}/monad-synapse:staging-latest
            ${{ secrets.CONTAINER_REGISTRY }}/monad-synapse:${{ needs.pre-deploy-checks.outputs.build-version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Image Information
        id: image-info
        run: |
          echo "image-tag=${{ needs.pre-deploy-checks.outputs.build-version }}" >> $GITHUB_OUTPUT

  # Deploy to Staging Infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks]
    environment: 
      name: staging
      url: https://staging.monad-synapse.com
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        working-directory: ./infrastructure/staging
        run: terraform init

      - name: Terraform Plan
        working-directory: ./infrastructure/staging
        run: |
          terraform plan \
            -var="app_version=${{ needs.pre-deploy-checks.outputs.build-version }}" \
            -var="environment=staging" \
            -out=staging.tfplan

      - name: Terraform Apply
        working-directory: ./infrastructure/staging
        run: terraform apply -auto-approve staging.tfplan

  # Application Deployment
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, container-build, deploy-infrastructure]
    environment: 
      name: staging
      url: https://staging.monad-synapse.com
    steps:
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v1
        with:
          manifests: |
            k8s/staging/deployment.yml
            k8s/staging/service.yml
            k8s/staging/ingress.yml
          images: |
            ${{ secrets.CONTAINER_REGISTRY }}/monad-synapse:${{ needs.pre-deploy-checks.outputs.build-version }}
          kubectl-version: 'v1.28.0'

      - name: Wait for Rollout
        run: |
          kubectl rollout status deployment/monad-synapse-staging -n staging --timeout=600s

      - name: Verify Deployment
        run: |
          kubectl get pods -n staging -l app=monad-synapse
          kubectl get services -n staging -l app=monad-synapse

  # Post-deployment Testing
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [deploy-application]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: |
          npm ci --prefer-offline --no-audit
          npm --workspace apps/web ci --prefer-offline --no-audit

      - name: Run Integration Tests
        working-directory: apps/web
        run: |
          npx jest __tests__/integration/ --ci --verbose
        env:
          TEST_BASE_URL: https://staging.monad-synapse.com
          NODE_ENV: test

      - name: API Health Checks
        run: |
          curl -f https://staging.monad-synapse.com/api/health || exit 1
          curl -f https://staging.monad-synapse.com/api/performance || exit 1

      - name: Lighthouse Staging Audit
        run: |
          npm install -g lighthouse
          lighthouse https://staging.monad-synapse.com \
            --output json \
            --output-path ./lighthouse-staging.json \
            --chrome-flags="--headless --no-sandbox"
          
          # Check performance score
          PERF_SCORE=$(cat lighthouse-staging.json | jq '.categories.performance.score * 100')
          echo "Performance Score: $PERF_SCORE"
          
          if (( $(echo "$PERF_SCORE < 80" | bc -l) )); then
            echo "Performance score too low: $PERF_SCORE"
            exit 1
          fi

  # Database Migration (if needed)
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks]
    if: contains(github.event.head_commit.message, '[migrate]')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Run Database Migration
        run: |
          # Add database migration commands here
          echo "Running database migrations for staging..."
          # Example: npm run migrate:staging

  # Notification and Reporting
  deployment-notification:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, deploy-application, integration-tests]
    if: always()
    steps:
      - name: Deployment Success Notification
        if: needs.deploy-application.result == 'success' && needs.integration-tests.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            ✅ Staging Deployment Successful
            Version: ${{ needs.pre-deploy-checks.outputs.build-version }}
            URL: https://staging.monad-synapse.com
            Commit: ${{ github.sha }}

      - name: Deployment Failure Notification
        if: needs.deploy-application.result == 'failure' || needs.integration-tests.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            ❌ Staging Deployment Failed
            Version: ${{ needs.pre-deploy-checks.outputs.build-version }}
            Commit: ${{ github.sha }}
            Please check the logs for details.

      - name: Create GitHub Deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'staging',
              description: 'Automated staging deployment',
              auto_merge: false
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: '${{ needs.deploy-application.result == 'success' && needs.integration-tests.result == 'success' && 'success' || 'failure' }}',
              environment_url: 'https://staging.monad-synapse.com',
              description: 'Deployment to staging environment'
            });

  # Cleanup
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [deployment-notification]
    if: always()
    steps:
      - name: Cleanup Old Artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            const oldArtifacts = artifacts.data.artifacts
              .filter(artifact => artifact.name.includes('staging-build'))
              .filter(artifact => new Date() - new Date(artifact.created_at) > 7 * 24 * 60 * 60 * 1000);
            
            for (const artifact of oldArtifacts) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id
              });
            }